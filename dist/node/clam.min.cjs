"use strict";require("reflect-metadata");var e=require("crypto-es"),t=require("tsyringe"),r=require("openpgp"),n=require("bitcore-mnemonic"),i=require("ethereum-hdwallet"),a=require("axios"),s=require("ethereumjs-util"),o=require("form-data"),c=require("buffer"),h=require("web3"),d=require("bowhead-web3"),m=require("ethereumjs-tx"),l=require("ethereumjs-common");function g(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var p=g(n),u=g(i),w=g(d);function y(e,t,r,n){var i,a=arguments.length,s=a<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,n);else for(var o=e.length-1;o>=0;o--)(i=e[o])&&(s=(a<3?i(s):a>3?i(t,r,s):i(t,r))||s);return a>3&&s&&Object.defineProperty(t,r,s),s}function f(e,t){return function(r,n){t(r,n,e)}}function v(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)}let I=class{constructor(){this.keySize=256,this.iterations=100}encryptData(t,r){if(0===t.trim().length||t.trim().length<3)throw new Error("Error, the length of the key to encrypt the data must be greater than 5");if(0===r.trim().length)throw new Error("The data must have at least one character");const n=e.lib.WordArray.random(16),i=e.PBKDF2(t,n,{keySize:this.keySize/32,iterations:this.iterations}),a=e.lib.WordArray.random(16),s=e.AES.encrypt(r,i,{iv:a,padding:e.pad.Pkcs7,mode:e.mode.CBC}),o=n.toString()+a.toString()+s.toString();return Promise.resolve(o)}decryptData(t,r){if(0===t.trim().length||t.trim().length<3)throw new Error("Error, the length of the key to decrypt the data must be greater than 5");if(0===r.trim().length)throw new Error("The data must have at least one character");const n=e.enc.Hex.parse(r.substr(0,32)),i=e.enc.Hex.parse(r.substr(32,32)),a=r.substring(64),s=e.PBKDF2(t,n,{keySize:this.keySize/32,iterations:this.iterations}),o=e.AES.decrypt(a,s,{iv:i,padding:e.pad.Pkcs7,mode:e.mode.CBC});return Promise.resolve(o.toString(e.enc.Utf8))}};I=y([t.injectable()],I);var E=I;let b=class{constructor(){this.encryptData=async(e,t)=>{if(0==t.trim().length)throw new Error("The data must have at least one character");const n=e.split(",").map((async e=>await r.readKey({armoredKey:e})));return(await r.encrypt({message:await r.createMessage({text:t}),encryptionKeys:await Promise.all(n)})).toString()},this.decryptData=async(e,t)=>{if(0==t.trim().length)throw new Error("The data must have at least one character");const n=e.split(",").map((async e=>await r.decryptKey({privateKey:await r.readPrivateKey({armoredKey:e}),passphrase:"passphrase"}))),i=await r.readMessage({armoredMessage:t}),{data:a}=await r.decrypt({message:i,decryptionKeys:await Promise.all(n)});return a.toString()}}};b=y([t.injectable()],b);var C=b;const{fromMnemonic:P}=u;let S=class{constructor(e,t){this.generateIdentity=async(e="")=>{if(""===this.mnemonic.trim()&&""===this.address.trim()&&""===this.privateKey.trim()&&""==this.publicKey.trim()){this.mnemonic=""===e.trim()?new p(p.Words.ENHLISH).toString():e;const t=P(this.mnemonic);this.address=`0x${t.derive("m/44'/60'/0'/0/0").getAddress().toString("hex")}`,this.privateKey=t.derive("m/44'/60'/0'/0/0").getPrivateKey(!0).toString("hex"),this.publicKey=t.derive("m/44'/60'/0'/0/0").getPublicKey(!0).toString("hex")}const t={name:this.address,email:`${this.address}@localhost.com`};if(!this.keysGenerator)throw new Error("Please set a specific implementation of keysGenerator");const{privateKey:r,publicKey:n}=await this.keysGenerator.generateKeys(t);this.privateKeySpecial=r,this.publicKeySpecial=n},this.mnemonic="",this.address="",this.privateKey="",this.publicKey="",this.privateKeySpecial="",this.publicKeySpecial="",this.encryptionLayer=e,this.keysGenerator=t}};S=y([t.injectable(),f(0,t.inject("EncryptionLayer")),f(1,t.inject("KeysGenerator")),v("design:paramtypes",[Object,Object])],S);var K=S;let M=class{constructor(){this.generateKeys=async e=>{const t={privateKey:"",publicKey:""},{name:n,email:i}=e,{privateKey:a,publicKey:s}=await r.generateKey({type:"ecc",curve:"curve25519",userIDs:[{name:n,email:i}],passphrase:"passphrase",format:"armored"});return t.privateKey=a,t.publicKey=s,t}}};M=y([t.injectable()],M);var F=M;class x{constructor(){this.optionsEncryptionLayer=[{name:"AES",option:E},{name:"PGP",option:C}],this.optionsKeysGenerator=[{name:"PGP",option:F}]}setOptionEncryption(e){if(this.optionsEncryptionLayer.find((t=>t.name===e.name)))throw new Error("This option already exists.");this.optionsEncryptionLayer.push(e)}setOptionKeysGenerator(e){if(this.optionsKeysGenerator.find((t=>t.name===e.name)))throw new Error("This option already exists.");this.optionsKeysGenerator.push(e)}generateIdentity(e,r){const n=this.optionsEncryptionLayer.find((t=>t.name.toLowerCase()===e.toLowerCase())),i=this.optionsKeysGenerator.find((e=>e.name.toLowerCase()===r.toLowerCase()));if(!n)throw new Error("The encryptionLayer type doesn't exist");if(!i)throw new Error("The keysGenerator type doesn't exist");t.container.register("EncryptionLayer",n.option),t.container.register("KeysGenerator",i.option);return t.container.resolve(K)}}const{fromMnemonic:j}=u;let T=class{constructor(e){this.engine=e}setConfiguration(e){this.engine.setConfiguration(e)}async saveFile(e){return await this.engine.saveFile(e)}async getFile(e){return await this.engine.getFile(e)}async updateFile(e){await this.engine.updateFile(e)}async deleteFile(e){await this.engine.deleteFile(e)}};T=y([t.injectable(),f(0,t.inject("Engine")),v("design:paramtypes",[Object])],T);var A=T;class L{setConfiguration(e){const t=e;this.instance=a.create({baseURL:t.URL,timeout:t.timeout,headers:{"x-api-key":t.ApiKey}})}async saveFile(e){const t=e,r=new o;r.append("file",t.file),r.append("address",t.address),r.append("fileName",t.fileName),r.append("keepOriginalName",String(t.keepOriginalName));return(await this.instance.post("/file",r)).data.CID}async getFile(e){const t=e;return(await this.instance.get(`/file?address=${t.address}&cid=${t.cid}`)).data.file}async updateFile(e){const t=e,r=new o,n=await this.getChallenge(t.address),i=this.generateSignature(n,t.privateKey);r.append("file",t.file),r.append("address",t.address),r.append("cid",t.cid||""),r.append("sigV",i.sigV.toString()),r.append("sigR",i.sigR),r.append("sigS",i.sigS),r.append("hash",n),await this.instance.put("/file",r)}async deleteFile(e){const t=e,r=await this.getChallenge(t.address),n=this.generateSignature(r,t.privateKey),i={address:t.address,cid:t.cid,hash:r,sigV:n.sigV,sigR:n.sigR,sigS:n.sigS};await this.instance.delete("/file",{data:i})}async getChallenge(e){return(await this.instance.get(`/challenge?address=${e}`)).data.hash}generateSignature(e,t){const r=c.Buffer.from(e,"hex"),n=c.Buffer.from(t,"hex"),{v:i,r:a,s:o}=s.ecsign(r,n);return{hash:e,sigR:a.toString("hex"),sigS:o.toString("hex"),sigV:i}}}let O=class{constructor(e,t){this.provider=new h(e),this.interactionConfig=t}getMethods(e){if(0===e.trim().length||""===e.trim())throw new Error("Please pass the contract name to interact.");let t,r="";if("consent"===e.trim().toLowerCase())t=this.interactionConfig.consent.abi,r=this.interactionConfig.consent.address;else if("access"===e.trim().toLowerCase())t=this.interactionConfig.access.abi,r=this.interactionConfig.access.address;else{if("IPFS"!==e.trim().toUpperCase())throw new Error("This contract doesn't exist.");t=this.interactionConfig.ipfs.abi,r=this.interactionConfig.ipfs.address}return new this.provider.eth.Contract(t,r).methods}async useContractMethod(e,t,r,...n){if("call"===r.action.trim().toLowerCase())return new Promise(((i,a)=>{e[r.methodName](...n).call({from:t.address},(function(e,t){e?a(e):i(t)}))}));if("send"===r.action.trim().toLowerCase()){const i=e[r.methodName](...n);return await this.signTransaction(i,t)}throw new Error("Invalid action, please select (send or call)")}async signTransaction(e,t){const r={to:e._parent._address,data:e.encodeABI(),gas:await e.estimateGas({from:t.address}),gasPrice:this.provider.utils.toHex(this.provider.utils.toWei("30","gwei"))},n=await this.provider.eth.accounts.signTransaction(r,t.privateKey);return await this.provider.eth.sendSignedTransaction(n.rawTransaction)}};O=y([t.injectable(),f(0,t.inject("Provider")),f(1,t.inject("Config")),v("design:paramtypes",[Object,Object])],O);var N=O;let k=class{constructor(){this.data=new Map}get(e){if(0===e.trim().length||""===e.trim())throw new Error("Error: Invalid key");return this.data.get(e)}set(e,t){if(0===e.trim().length||""===e.trim())throw new Error("Error: Invalid key");if("string"==typeof t&&(0===t.trim().length||""===t.trim()))throw new Error("Error: Empty value");this.data.set(e.trim(),"string"==typeof t?t.trim():t)}delete(e){if(0===e.trim().length||""===e.trim())throw new Error("Error: Invalid key");this.data.delete(e.trim())}clear(){this.data.clear()}};k=y([t.injectable(),v("design:paramtypes",[])],k);var D=k;t.container.register("memory",D),t.container.register("localStorage",class{get(e){return JSON.parse(localStorage.getItem(e))}set(e,t){localStorage.setItem(e,JSON.stringify(t))}delete(e){localStorage.removeItem(e)}clear(){localStorage.clear()}});class G{constructor(e,r){this.cacheEngine=t.container.resolve(e),this.cacheEngine.set("nonce",r)}get(){return Number(this.cacheEngine.get("nonce"))}save(e){this.cacheEngine.set("nonce",e)}}let R=class{constructor(e,t){this.provider=new w(new w.providers.HttpProvider(e)),this.interactionConfig=t,this.nonceManager=new G("cache",0)}getMethods(e){let t,r="";"consent"===e.trim().toLowerCase()?(t=this.interactionConfig.consent.abi,r=this.interactionConfig.consent.address):"access"===e.trim().toLowerCase()?(t=this.interactionConfig.access.abi,r=this.interactionConfig.access.address):(t=this.interactionConfig.consent.abi,r=this.interactionConfig.consent.address);return new this.provider.aht.contract(t).at(r)}async useContractMethod(e,t,r,...n){try{if("send"===r.action.trim()){const i=await this.getNonce(t.address);this.nonceManager.save(i>this.nonceManager.get()?i:this.nonceManager.get());const a={to:q.getInstance().config.consent.address,nonce:this.provider.toHex(this.nonceManager.get()),gasPrice:0,gasLimit:5e7,value:"0x0",data:e[r.methodName].getData.apply(e,n),chainId:q.getInstance().config.chainId},s=await this.signTransaction(a,t),o=await this.sendSignedTransaction(s),c=await this.getTransactionReceipt(o);return this.nonceManager.save(this.nonceManager.get()+1),c}{const i=e[r.methodName].bind(e,...n,{from:t.address});return await this.promersify(i)}}catch(e){return!1}}getNonce(e){return new Promise(((t,r)=>{this.provider.aht.getTransactionCount(e,((e,n)=>{e?r({status:500,message:"Blockchain error: calculating the nonce",systemMessage:e}):t(n)}))}))}async signTransaction(e,t){const r=l.forCustomChain("mainnet",{name:"aht",chainId:e.chainId},"petersburg"),n=new m.Transaction(e,{common:r});return n.sign(Buffer.from(t.privateKey.substring(2,t.privateKey.length),"hex")),n.serialize()}sendSignedTransaction(e){return new Promise(((t,r)=>{this.provider.aht.sendRawTransaction("0x"+e.toString("hex"),((e,n)=>{e&&r({status:500,message:"Blockchain Error: sending transaction",systemMessage:e}),t(n)}))}))}getTransactionReceipt(e){return new Promise(((t,r)=>{this.provider.aht.getTransactionReceipt(e,((e,n)=>{e?r(e):t(n)}))}))}promersify(e){return new Promise(((t,r)=>{e(((e,n)=>{e?r(e):t(n)}))}))}};R=y([t.injectable(),f(0,t.inject("Provider")),f(1,t.inject("Config")),v("design:paramtypes",[Object,Object])],R);var B=R;class q{constructor(){this.web3Providers=[{name:"web3",option:N},{name:"bowhead",option:B}]}static getInstance(){return q.instance||(this.instance=new q),this.instance}setConfig(e){this.config=e}setOptionWeb3Provider(e){if(""===e.name.trim()&&0===e.name.trim().length)throw new Error("The name must have at least one character");const t=this.web3Providers.find((t=>t.name===e.name));t?this.web3Providers.map((e=>e.name===t.name?t:e)):this.web3Providers.push(e)}generateWeb3Provider(e){if(0===e.trim().length||""===e.trim())throw new Error("The name must have at least one character");const r=this.web3Providers.find((t=>t.name.trim().toLowerCase()===e.trim().toLowerCase()));if(!r)throw new Error("The web3 provider type doesn't exist");t.container.register("Provider",{useValue:this.config.provider}),t.container.register("Config",{useValue:this.config});return t.container.resolve(r.option)}}let H=class{constructor(){this.provider=q.getInstance().generateWeb3Provider("web3")}async giveAccess(e,t,r,n,i){if(""===e.trim()||0===e.trim().length)throw new Error("The resource must have at least one character");if(""===t.trim()||0===t.trim().length)throw new Error("The consentID must have at least one character");if(0===r.length)throw new Error("Accounts must have at least one element");const a=this.provider.getMethods("access");return(await this.provider.useContractMethod(a,i,{action:"send",methodName:"giveAccess"},e,h.utils.fromAscii(t),r,h.utils.fromAscii(n))).status}async checkAccess(e,t,r){if(""===e.trim()||0===e.trim().length)throw new Error("The resource must have at least one character");if(""===t.trim()||0===t.trim().length)throw new Error("The consentID must have at least one character");const n=this.provider.getMethods("access");return await this.provider.useContractMethod(n,r,{action:"call",methodName:"checkAccess"},e,h.utils.fromAscii(t))}async getResourceByConsent(e,t){if(""===e.trim()||0===e.trim().length)throw new Error("The consentID must have at least one character");const r=this.provider.getMethods("access");return this.provider.useContractMethod(r,t,{action:"call",methodName:"getResourceByConsent"},h.utils.fromAscii(e))}};H=y([t.injectable()],H);var W=H;let $=class{constructor(){this.provider=q.getInstance().generateWeb3Provider("web3")}async saveConsent(e,t){if(""===e.trim()||0===e.trim().length)throw new Error("contentID must have at least 1 character");const r=this.provider.getMethods("consent");return(await this.provider.useContractMethod(r,t,{action:"send",methodName:"updateConsent"},h.utils.fromAscii(e),!0)).status}async cancelConsent(e,t){if(""===e.trim()||0===e.trim().length)throw new Error("contentID must have at least 1 character");const r=this.provider.getMethods("consent");return(await this.provider.useContractMethod(r,t,{action:"send",methodName:"updateConsent"},h.utils.fromAscii(e),!1)).status}async getConsentById(e,t,r){if(""===e.trim()||0===e.trim().length)throw new Error("contentID must have at least 1 character");if(""===t.trim()||0===t.trim().length)throw new Error("Owner must have at least 1 character");if(!t.trim().includes("0x"))throw new Error("Invalid owner, the string with has a correct format.");const n=this.provider.getMethods("consent");return await this.provider.useContractMethod(n,r,{action:"call",methodName:"getConsent"},h.utils.fromAscii(e),t)}async addKey(e,t,r,n){if(""===e.trim()||0===e.trim().length)throw new Error("contentID must have at least 1 character");if(""===t.trim()||0===t.trim().length)throw new Error("AddressConsent must have at least 1 character");if(!t.trim().includes("0x"))throw new Error("Invalid addressConsent, the string with has a correct format.");if(0===r.trim().length||""===r.trim())throw new Error("Key must have at least 1 character");const i=this.provider.getMethods("consent");return(await this.provider.useContractMethod(i,n,{action:"send",methodName:"addPGPKey"},h.utils.fromAscii(e),t,r)).status}async getKeys(e,t){if(""===e.trim()||0===e.trim().length)throw new Error("contentID must have at least 1 character");const r=this.provider.getMethods("consent");return await this.provider.useContractMethod(r,t,{action:"call",methodName:"getPGPKeys"},h.utils.fromAscii(e))}};$=y([t.injectable()],$);var z=$;let V=class{constructor(e,t,r){this.accessInteraction=t,this.consentInteraction=e,this.IPFSManagementInteraction=r}setUrlProvider(e){this.urlProvider=e}setIdentity(e){this.identity=e}};V=y([t.injectable(),f(0,t.inject("ConsentInteraction")),f(1,t.inject("AccessInteraction")),f(2,t.inject("IPFSManagementInteraction")),v("design:paramtypes",[Object,Object,Object])],V);var U=V;let J=class{constructor(){this.provider=q.getInstance().generateWeb3Provider("web3")}async addFile(e,t,r){if(""===e.trim()||0===e.trim().length)throw new Error("fileHash must have at least 1 character");if(""===t.trim()||0===t.trim().length)throw new Error("fileName must have at least 1 character");const n=this.provider.getMethods("IPFS");await this.provider.useContractMethod(n,r,{action:"send",methodName:"addFile"},e,h.utils.fromAscii(t))}async removeFile(e,t){if(""===e.trim()||0===e.trim().length)throw new Error("fileHash must have at least 1 character");const r=this.provider.getMethods("IPFS");await this.provider.useContractMethod(r,t,{action:"send",methodName:"removeFile"},e)}async checkAccess(e,t){if(""===e.trim()||0===e.trim().length)throw new Error("fileHash must have at least 1 character");const r=this.provider.getMethods("IPFS");return await this.provider.useContractMethod(r,t,{action:"call",methodName:"checkAccess"},t.address,e)}async fileIsAvailable(e,t){if(""===e.trim()||0===e.trim().length)throw new Error("fileHash must have at least 1 character");const r=this.provider.getMethods("IPFS");return await this.provider.useContractMethod(r,t,{action:"call",methodName:"fileIsAvailable"},t.address,e)}async getFiles(e){const t=this.provider.getMethods("IPFS");return await this.provider.useContractMethod(t,e,{action:"call",methodName:"getFiles"},e.address)}};J=y([t.injectable()],J);var _=J;class Y{constructor(){}static getInstance(){return Y.instance||(Y.instance=new Y),this.instance}setConfig(e,t){this.web3Object=e,this.interactionConfig=t}getProvider(){return this.web3Object}}let Q=class{constructor(e){this.storageEngine=e}async saveFile(e,t){const r=t;if(!r.file)throw new Error("File parameter is missing");if(!await r.contractInteraction.consentInteraction.getConsentById(r.consentId,e.address,e))throw new Error("Consent is not approved");const n={file:await e.encryptionLayer.encryptData(e.privateKey,r.file||""),address:e.address,fileName:r.fileName,keepOriginalName:r.keepOriginalName||!1};return await this.storageEngine.saveFile(n)}async getFile(e,t){const r=t;if(!r.cid)throw new Error("File identifier is missing");const n={cid:r.cid,address:e.address},i=await this.storageEngine.getFile(n),a=Buffer.from(i,"base64").toString("utf8");return e.encryptionLayer.decryptData(e.privateKey,a)}async updateFile(e,t){const r=t;if(!r.file)throw new Error("File parameter is missing");const n={file:await e.encryptionLayer.encryptData(e.privateKey,r.file),address:e.address,cid:r.cid,privateKey:e.privateKey};await this.storageEngine.updateFile(n)}async sharedFile(e,t,r){const n=t;if(!n.file)throw new Error("File parameter is missing");if(!await n.contractInteraction.consentInteraction.getConsentById(n.consentId,e.address,e))throw new Error("Consent is not approved");r+=`,${e.publicKeySpecial}`;const i={file:await e.encryptionLayer.encryptData(r,n.file),address:e.address,fileName:n.fileName,keepOriginalName:n.keepOriginalName||!1};return await this.storageEngine.saveFile(i)}async getSharedFile(e,t){const r=t;if(!r.cid)throw new Error("File identifier is missing");if(!await r.contractInteraction.accessInteraction.checkAccess(r.cid,r.consentId,e))throw new Error("You do not have access to the resource");const n={cid:r.cid,address:r.owner||""},i=await this.storageEngine.getFile(n),a=Buffer.from(i,"base64").toString("utf8");return await e.encryptionLayer.decryptData(e.privateKeySpecial,a)}};Q=y([t.injectable(),v("design:paramtypes",[Object])],Q);var X=Q;exports.DocumentSharing=X,exports.EncryptionLayerAES=E,exports.EncryptionLayerPGP=C,exports.FactoryIdentity=x,exports.FactoryInteraction=class{constructor(){this.optionsConsentInteraction=[{name:"clam",option:z}],this.optionsAccessInteraction=[{name:"clam",option:W}],this.optionsIPFSManagementInteraction=[{name:"clam",option:_}]}setOptionConsentInteraction(e){if(""===e.name.trim()&&0===e.name.trim().length)throw new Error("The name must have at least one character");if(this.optionsConsentInteraction.find((t=>t.name===e.name)))throw new Error("This option already exists.");this.optionsConsentInteraction.push(e)}setOptionAccessInteraction(e){if(""===e.name.trim()&&0===e.name.trim().length)throw new Error("The name must have at least one character");if(this.optionsAccessInteraction.find((t=>t.name===e.name)))throw new Error("This option already exists.");this.optionsAccessInteraction.push(e)}setOptionsIPFSManagementInteraction(e){if(""===e.name.trim()&&0===e.name.trim().length)throw new Error("The name must have at least one character");if(this.optionsIPFSManagementInteraction.find((t=>t.name===e.name)))throw new Error("This option already exists.");this.optionsIPFSManagementInteraction.push(e)}generateInteraction(e,r,n){if(""===e.trim()&&0===e.trim().length)throw new Error("The consent implementation name must have a minimum of one character");if(""===r.trim()&&0===r.trim().length)throw new Error("The access implementation name must have a minimum of one character");if(""===n.trim()&&0===n.trim().length)throw new Error("The IPFS management implementation name must have a minimum of one character");const i=this.optionsConsentInteraction.find((t=>t.name.toLowerCase()===e.toLowerCase())),a=this.optionsAccessInteraction.find((e=>e.name.toLowerCase()===r.toLowerCase())),s=this.optionsIPFSManagementInteraction.find((e=>e.name.toLowerCase()===n.toLowerCase()));if(!i)throw new Error("The consentInteraction type doesn't exist");if(!a)throw new Error("The accessInteraction type doesn't exist");if(!s)throw new Error("The IPFSManagementInteraction type doesn't exist");t.container.register("ConsentInteraction",i.option),t.container.register("AccessInteraction",a.option),t.container.register("IPFSManagementInteraction",s.option);return t.container.resolve(U)}},exports.FactoryWeb3Interaction=q,exports.IdentityManager=K,exports.KeysGeneratorPGP=F,exports.ShareableIdentity=class{constructor(e){this.generateIdentities=async e=>{if(0===e||e<1)throw new Error("The count must be greater than 0");if(0==this.mainIdentity.mnemonic.length)throw new Error("The main identity has to be initialized");{const t=j(this.mainIdentity.mnemonic);let r="",n="",i="";for(let a=this.lastIdentity;a<=e;a++){r=`0x${t.derive(`m/44'/60'/0'/0/${a}`).getAddress().toString("hex")}`,n=t.derive(`m/44'/60'/0'/0/${a}`).getPrivateKey(!0).toString("hex"),i=t.derive(`m/44'/60'/0'/0/${a}`).getPublicKey(!0).toString("hex");const e=new K(this.mainIdentity.encryptionLayer,this.mainIdentity.keysGenerator);e.mnemonic=this.mainIdentity.mnemonic,e.address=r,e.privateKey=n,e.publicKey=i,await e.generateIdentity(),this.identities.push(e),this.lastIdentity++}}},this.getIdentityByIndex=e=>{if(e<0)throw new Error("Position must be equal or greater than 0");let t=(new x).generateIdentity("PGP","PGP");return e>=0&&e<this.identities.length&&(t=this.identities[e],this.identities[e]),t},this.mainIdentity=e,this.identities=[],this.lastIdentity=1}},exports.Storage=A,exports.StorageEngine=class{constructor(e){const r=t.container.createChildContainer();e?r.register("Engine",{useClass:e}):r.register("Engine",{useClass:L}),this.storageEngine=r.resolve(A)}getStorageEngine(){return this.storageEngine}},exports.Web3Provider=Y;
//# sourceMappingURL=clam.min.cjs.map
